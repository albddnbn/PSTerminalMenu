

function Scan-Inventory {
    <#
    .SYNOPSIS
        Scan-Inventory helps to create a spreadsheet of inventory items. 
        No one will want to waste time actually using an application to make small/day to day changes in toner stock, 
        but it will make things easier to have a spreadsheet where items are named exactly how they're written on box.

    .DESCRIPTION
        As of Dec. 5, 2023 --> Not finished yet, though Scan-Inventory is functional.

    .PARAMETER ScanTitle
        Title of the scan, will be used to name the output file(s).

    .NOTES
        Additional notes about the file.

    #>
    param(
        $ScanTitle = 'Inventory'
    )


    # creates item with specified properties (in parameters) and then prompts user to keep or change each value, returns changed object
    Function Create-NewItemObject {
        param(
            $Description = '',
            $Compatible_printers = '',
            $code = '',
            $UPC = '',
            $Stock = '',
            $Part_num = '',
            $color = '',
            $brand = '',
            $yield = '',
            $type = '',
            $comments = '',
            $ean = ''
        )
        $obj = [pscustomobject]@{
            Description         = $Description
            Compatible_printers = $Compatible_printers
            code                = $code
            UPC                 = $UPC
            Stock               = $Stock
            # need to see how i can parse this
            Part_num            = $Part_num
            color               = $color
            brand               = $brand
            yield               = $yield
            type                = $type
            comments            = $comments
            ean                 = $ean
        }
        # These property values are SKIPPED when item is scanned / prompting for new values:
        $SKIPPED_PROPERTY_VALUES = @('upc', 'type', 'Compatible_printers', 'ean', 'yield', 'color')
        $obj.PSObject.Properties | ForEach-Object {
            if ($_.Name -notin $SKIPPED_PROPERTY_VALUES) {
                
                $current_value = $_.Value
                Write-Host "Current value of $($_.Name) is: $($_.Value), enter 'keep' to retain value."
                $_.Value = Read-Host "Enter value for $($_.Name)"
                if ($_.Value -eq 'k') {
                    $_.Value = $current_value
                }
            }
        }
        return $obj
    }

    # ---- VARIABLES section ----
    $MASTER_CSV_FILE = "$env:PSMENU_DIR\inventory\master-inventory.csv" # holds all items that have been scanned in, for all time
    $API_URL = "https://api.upcitemdb.com/prod/trial/lookup?upc="

    # SOUNDS
    $POSITIVE_BEEP_PATH = "$env:PSMENU_DIR\inventory\sounds\positivebeep.wav"
    $NEGATIVE_BEEP_PATH = "$env:PSMENU_DIR\inventory\sounds\negativebeep.wav"

    # making sure master .csv file exists
    if (-not (Test-path "$env:PSMENU_DIR\inventory\master-inventory.csv" -erroraction SilentlyContinue)) {
        New-Item -Path "$env:PSMENU_DIR\inventory\master-inventory.csv" -ItemType 'File' -Force | Out-Null
    }

    # import items from master_csv
    $MASTER_ITEM_LIST = import-csv $MASTER_CSV_FILE

    # create output filename for inventory report (this is different from the master list file, this is the report being generated by this current/run of the function)
    $outputfile = Get-OutputFileString -Titlestring $ScanTitle -rootdirectory $env:PSMENU_DIR -foldertitle $REPORT_DIRECTORY -reportoutput

    Write-Host "Output file(s) will be at: $outputfile .csv/.xlsx" -foregroundcolor green

    $CURRENT_INVENTORY = [System.collections.arraylist]::new() # holds items scanned during this run of the function, will be output to report .csv/.xlsx

    # begin 'scan looop' where user scans items. First - the scanned code is checked against the master item list, if it's not found, the script sends a request to the API URL with scanned code to try to get details.
    while ($true) {

        $user_input = Read-Host "Scan code, or type 'exit' to quit"
        if ($user_input.ToLower() -eq 'exit') {
            break
        }

        $ITEM_FOUND = $false # signifies if item has been found in master list or by api

        # CHECK CURRENT INVENTORY ARRAYLIST
        $CURRENT_INVENTORY | ForEach-Object {
            if ($user_input -in @($_.upc)) {
                Write-Host "Found match for $user_input in current inventory, increasing stock by 1."
                $ITEM_FOUND = $true

                $player = New-Object System.Media.SoundPlayer
                $player.SoundLocation = $POSITIVE_BEEP_PATH
                $player.Load()
                $player.Play()
            }
        }

        # CHECK MASTER LIST .CSV/ARRAYLIST
        # if scanned code matches any item's upc/ean/code/partnum - add item to current_inventory and/or increase stock by 1
        if ($user_input -notin $($CURRENT_INVENTORY.UPC)) {
            $MASTER_ITEM_LIST | ForEach-Object {
                # if ($user_input -in @($_.upc, $_.ean, $_.code, $_.part_num)) {
                if ($user_input -in @($_.upc)) {
                    Write-Host "Found match in master list for $($user_input), adding item to current list. "
                    $CURRENT_INVENTORY.Add($_) | Out-Null
                    $ITEM_FOUND = $true

                    $player = New-Object System.Media.SoundPlayer
                    $player.SoundLocation = $POSITIVE_BEEP_PATH
                    $player.Load()
                    $player.Play()
                }
            }
        }
        # STILL NOT FOUND? -> CHECK API / WEBSITE, if not found there - prompt user for manual entry of item details.
        if (-not $ITEM_FOUND) {
                            
            $player = New-Object System.Media.SoundPlayer
            $player.SoundLocation = $NEGATIVE_BEEP_PATH
            $player.Load()
            $player.Play()
            # if reaches this point, then item is not already in the lists so API has to be checked.
            $api_response = Invoke-WebRequest -URI "$API_URL$($user_input)"

            # convert api_response content from json
            $json_response_content = $api_response.content | ConvertFrom-Json
            # make sure response was 'ok'
            if ($json_response_content.code -eq 'OK') {

                Write-Host "API response for $user_input was 'OK', here are the results:" -Foregroundcolor Green
                Write-Host ""


                $menu_options = $json_response_content.items.title | sort

                $item_details = $json_response_content.items | where-object { $_.title -eq $($menu_options | select -first 1) }
                $useful_details = $item_details | Select ean, title, description, upc, brand, model, color, dimension, category



                $useful_details | Format-List


                Write-Host ""

                # present menu - user can choose between multiple item results (theoretically):

                $chosen_item_name = Menu $menu_options

                Write-Host ""
                $chosen_item_code = $chosen_item_name.model
                $chosen_item_part_num = $chosen_item_name.model
                $chosen_item_upc = $chosen_item_name.upc
                $chosen_item_ean = $chosen_item_name.ean
                $chosen_item_brand = $chosen_item_name.brand
                $chosen_item_color = $chosen_item_name.color

                $obj = Create-NewItemObject -Description $chosen_item_name -code $chosen_item_code -UPC $chosen_item_upc -Part_num $chosen_item_part_num -color $chosen_item_color -brand $chosen_item_brand -ean $chosen_item_ean

                Write-Host "[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')] :: Adding the object to inventory_csv variable.."
                $CURRENT_INVENTORY.add($obj) | Out-Null
                # $inventory_csv += $obj
            }
            else {

                Write-Host "API was unable to find matching item for: $user_input."
                $response = Menu @('Scan again?', 'Create item manually')
                if ($repsonse -eq 'Scan again?') {
                    continue
                }
                else {
                    $obj = Create-NewItemObject -UPC $user_input
                    $CURRENT_INVENTORY.add($obj) | Out-Null

                }
            }

        }

        # whatever happens, when code hits this point, there will be an entry for the scanned code in current_inventory arraylist, so increase stock by 1
        $CURRENT_INVENTORY | ForEach-Object {
            if ($user_input -in @($_.upc)) {
                $_.stock = [string]$([int]$_.stock + 1)
                Write-Host "Found match for $user_input in current inventory, increasing stock by 1."
                # positive beep plays since item was located and stock was increased without user intervention
            }
        }

    }

    ## INVENTORY SPREADSHEET CREATION (end of scanning loop):

    # script creates a .csv / .xlsx report from CURRENT_INVENTORY arraylist
    Write-Host "[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')] :: Exporting scanned inventory to " -NoNewline
    Write-Host "$outputfile.csv and $outputfile.xlsx" -Foregroundcolor Green
    $CURRENT_INVENTORY | Export-CSV "$outputfile.csv" -NoTypeInformation -Force

    # look for the importexcel powershell module
    $CheckForimportExcel = Get-InstalledModule -Name 'importexcel' -ErrorAction SilentlyContinue
    if (-not $CheckForimportExcel) {
        Install-Module -Name ImportExcel -Force
    }

    $params = @{
        AutoSize             = $true
        TitleBackgroundColor = 'Blue'
        TableName            = "$ScanTitle"
        TableStyle           = 'Medium9' # => Here you can chosse the Style you like the most
        BoldTopRow           = $true
        WorksheetName        = $ScanTitle
        PassThru             = $true
        Path                 = "$OutPutFile.xlsx" # => Define where to save it here!
    }

    $xlsx = $CURRENT_INVENTORY | Export-Excel @params
    $ws = $xlsx.Workbook.Worksheets[$params.Worksheetname]
    $ws.View.ShowGridLines = $false # => This will hide the GridLines on your file
    Close-ExcelPackage $xlsx

    # Explorer.exe $env:PSMENU_DIR\reports\$thedate\$REPORT_DIRECTORY
    Invoke-Item "$outputfile.xlsx"

}
